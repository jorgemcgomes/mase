/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mase.spec;

import ec.EvolutionState;
import ec.Exchanger;
import ec.Individual;
import ec.Population;
import ec.Subpopulation;
import mase.evaluation.CoevolutionaryEvaluator;
import ec.util.Parameter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import mase.evaluation.MetaEvaluator;
import mase.evaluation.BehaviourResult;
import mase.evaluation.EvaluationResult;
import mase.evaluation.ExpandedFitness;
import mase.evaluation.SubpopEvaluationResult;

/**
 *
 * @author jorge
 */
public abstract class AbstractHybridExchanger extends Exchanger {

    public static final String P_HOMOGENEOUS_START = "homogeneous-start";
    int popSize, nAgents;
    boolean homogeneousStart;
    List<MetaPopulation> metaPops;
    int[] allocations;

    @Override
    public void setup(EvolutionState state, Parameter base) {
        allocations = new int[state.parameters.getInt(new Parameter("pop.subpops"), null)]; // TODO: bad fix
        for (int i = 0; i < allocations.length; i++) {
            allocations[i] = i;
        }
        nAgents = allocations.length;
        homogeneousStart = state.parameters.getBoolean(base.push(P_HOMOGENEOUS_START), null, false);
    }

    /*
     * Generic hybrid exchanger mechanics, with support for foreign individuals
     */
    @Override
    public Population preBreedingExchangePopulation(EvolutionState state) {
        // initialization -- first time in each evolutionary run
        if (metaPops == null) {
            popSize = state.population.subpops[0].individuals.length;
            metaPops = new ArrayList<MetaPopulation>();
            initializationProcess(state);
        }

        // the evaluation has passed - update ages
        for (MetaPopulation mp : metaPops) {
            mp.age++;
            for (Foreign f : mp.foreigns) {
                f.age++;
            }
        }

        splitProcess(state);
        mergeProcess(state);
        updateRepresentatives(state);

        importForeignPreBreed(state);
        // create new population with individuals from metapops, without foreigns
        Population newPop = (Population) state.population.emptyClone();
        newPop.subpops = new Subpopulation[metaPops.size()];
        for (int i = 0; i < metaPops.size(); i++) {
            newPop.subpops[i] = metaPops.get(i).pop;
            newPop.subpops[i].individuals = metaPops.get(i).inds;
        }
        return newPop;
    }

    /*
     Update after breeding and prepare populations for evaluation
     */
    @Override
    public Population postBreedingExchangePopulation(EvolutionState state) {
        // Update metapop with new individuals generated by the breeding process
        for (int i = 0; i < metaPops.size(); i++) {
            MetaPopulation mp = metaPops.get(i);
            mp.pop = state.population.subpops[i];
            mp.inds = state.population.subpops[i].individuals;
        }

        importForeignPostBreed(state);

        // Add foreign individuals to the subpopulations for evaluation        
        for (MetaPopulation mp : metaPops) {
            for (Foreign f : mp.foreigns) {
                Individual[] newInds = Arrays.copyOf(mp.pop.individuals, mp.pop.individuals.length + f.inds.length);
                System.arraycopy(f.inds, 0, newInds, mp.pop.individuals.length, f.inds.length);
                mp.pop.individuals = newInds;
            }
        }

        // Update allocations
        for (int i = 0; i < metaPops.size(); i++) {
            for (Integer ag : metaPops.get(i).agents) {
                allocations[ag] = i;
            }
        }

        return state.population;
    }

    protected abstract void importForeignPreBreed(EvolutionState state);

    protected abstract void importForeignPostBreed(EvolutionState state);

    protected void updateRepresentatives(EvolutionState state) {
        CoevolutionaryEvaluator base = (CoevolutionaryEvaluator) ((MetaEvaluator) state.evaluator).getBaseEvaluator();
        Individual[][] newElites = new Individual[metaPops.size()][base.getEliteIndividuals()[0].length];
        for (int i = 0; i < metaPops.size(); i++) {
            MetaPopulation mp = metaPops.get(i);

            // Make a pool with all individuals (self + all foreigns)
            Individual[] allInds = Arrays.copyOf(mp.inds, mp.inds.length);
            for (Foreign f : mp.foreigns) {
                if (f.inds != null) {
                    allInds = Arrays.copyOf(allInds, allInds.length + f.inds.length);
                    System.arraycopy(f.inds, 0, allInds, allInds.length - f.inds.length, f.inds.length);
                }
            }
            allInds = sortedCopy(allInds);
            for (int j = 0; j < newElites[i].length; j++) {
                newElites[i][j] = (Individual) allInds[j].clone();
            }
        }
        base.setEliteIndividuals(newElites);
    }

    /*
     Initialization, merging and spliting algorithms
     */
    protected void initializationProcess(EvolutionState state) {
        if (homogeneousStart) {
            MetaPopulation homo = new MetaPopulation();
            for (int i = 0; i < state.population.subpops.length; i++) {
                homo.agents.add(i);
            }
            homo.pop = state.population.subpops[0];
            homo.inds = homo.pop.individuals;
            metaPops.add(homo);
        } else {
            for (int i = 0; i < state.population.subpops.length; i++) {
                MetaPopulation pi = new MetaPopulation();
                pi.agents.add(i);
                pi.pop = state.population.subpops[i];
                pi.inds = pi.pop.individuals;
                metaPops.add(pi);
            }
        }
    }

    /* Similar to bottom-up (agglomerative) hierarchical clustering */
    protected abstract void mergeProcess(EvolutionState state);

    protected abstract void splitProcess(EvolutionState state);

    protected static class MetaPopulation {

        List<Integer> agents;
        Subpopulation pop;
        Individual[] inds;
        int age;
        List<Foreign> foreigns;

        MetaPopulation() {
            this.agents = new ArrayList<Integer>();
            this.age = 0;
            this.foreigns = new LinkedList<Foreign>();
        }

        @Override
        public String toString() {
            String s = "[";
            for (int i = 0; i < agents.size() - 1; i++) {
                s += agents.get(i) + ",";
            }
            if (agents.size() > 0) {
                s += agents.get(agents.size() - 1);
            }
            return s + "]";
        }
    }

    protected static class Foreign {

        MetaPopulation origin;
        Individual[] inds;
        int age;

        Foreign(MetaPopulation origin) {
            this.origin = origin;
            this.age = 0;
            this.inds = null;
        }

    }

    /*
     Uses final scores
     Sorts from the highest fitness to the lowest fitness
     */
    protected class FitnessComparator implements Comparator<Individual> {

        @Override
        public int compare(Individual o1, Individual o2) {
            return Double.compare(o2.fitness.fitness(), o1.fitness.fitness());
        }
    }

    protected Individual[] sortedCopy(Individual[] inds) {
        inds = Arrays.copyOf(inds, inds.length);
        Arrays.sort(inds, new FitnessComparator());
        return inds;
    }

    protected Individual[] getElitePortion(Individual[] inds, int num) {
        inds = sortedCopy(inds);
        Individual[] elite = new Individual[num];
        System.arraycopy(inds, 0, elite, 0, num);
        return elite;
    }

    protected BehaviourResult getAgentBR(Individual ind, int agent) {
        ExpandedFitness nf = (ExpandedFitness) ind.fitness;
        for (EvaluationResult er : nf.getEvaluationResults()) {
            if (er instanceof SubpopEvaluationResult) {
                SubpopEvaluationResult ser = (SubpopEvaluationResult) er;
                return (BehaviourResult) ser.getSubpopEvaluation(agent);
            }
        }
        return null;
    }

    public int[] getAllocations() {
        return allocations;
    }

    protected List<MetaPopulation> getMetaPopulations() {
        return metaPops;
    }

    @Override
    public String runComplete(EvolutionState state) {
        return null;
    }

}

/*List<Individual> sorted = new LinkedList<Individual>();
 sorted.addAll(Arrays.asList(mp.inds));
 for(Foreign f : mp.foreigns)*/
/*List<Pair<Individual, MetaPopulation>> sorted = new LinkedList<Pair<Individual, MetaPopulation>>();
 for (Individual ind : mp.inds) {
 sorted.add(Pair.of(ind, mp));
 }
 for (Foreign f : mp.foreigns) {
 if(f.inds != null) {
 for (Individual ind : f.inds) {
 sorted.add(Pair.of(ind, f.origin));
 }
 }
 }

 // Sort the individuals from the pool
 final FitnessComparator fc = new FitnessComparator();
 Collections.sort(sorted, new Comparator<Pair<Individual, MetaPopulation>>() {
 @Override
 public int compare(Pair<Individual, MetaPopulation> o1, Pair<Individual, MetaPopulation> o2) {
 return fc.compare(o1.getLeft(), o2.getLeft());
 }
 });

 // Select the top individuals as the representatives
            
 int foreign = 0;
 for (int j = 0; j < newElites[i].length; j++) {
 Pair<Individual, MetaPopulation> next = sorted.get(j);
 newElites[i][j] = (Individual) next.getLeft().clone();
 if (next.getRight() != mp) {
 foreign++;
 }
 }
 System.out.println("Elite " + i + ": " + newElites[i][0].fitness.fitness()
 + (foreign == 1 ? "(foreign)" : ""));*/
