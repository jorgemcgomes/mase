/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mase.spec;

import ec.EvolutionState;
import ec.Exchanger;
import ec.Individual;
import ec.Population;
import ec.Subpopulation;
import mase.evaluation.CoevolutionaryEvaluator;
import ec.util.Parameter;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import mase.evaluation.MetaEvaluator;
import mase.evaluation.BehaviourResult;
import mase.evaluation.ExpandedFitness;
import mase.evaluation.SubpopEvaluationResult;

/**
 *
 * @author jorge
 */
public abstract class AbstractHybridExchanger extends Exchanger {

    public static final String P_HOMOGENEOUS_START = "homogeneous-start";
    public static final String P_BEHAVIOUR_INDEX = "behaviour-index";
    private static final long serialVersionUID = 1L;
    int popSize, nAgents;
    int behaviourIndex;
    boolean homogeneousStart;
    List<MetaPopulation> metaPops;
    int[] allocations;
    int merges, splits;

    @Override
    public void setup(EvolutionState state, Parameter base) {
        allocations = new int[state.parameters.getInt(new Parameter("pop.subpops"), null)]; // TODO: bad fix
        for (int i = 0; i < allocations.length; i++) {
            allocations[i] = i;
        }
        nAgents = allocations.length;
        behaviourIndex = state.parameters.getInt(base.push(P_BEHAVIOUR_INDEX), null);
        homogeneousStart = state.parameters.getBoolean(base.push(P_HOMOGENEOUS_START), null, false);
    }

    /*
     * Generic hybrid exchanger mechanics, with support for foreign individuals
     */
    @Override
    public Population preBreedingExchangePopulation(EvolutionState state) {
        // initialization -- first time in each evolutionary run
        if (metaPops == null) {
            popSize = state.population.subpops[0].individuals.length;
            metaPops = new ArrayList<>();
            initializationProcess(state);
        }

        // the evaluation has passed - update ages
        for (MetaPopulation mp : metaPops) {
            mp.age++;
        }
        merges = 0;
        splits = 0;

        // Only allows one operation per generation
        // reason: its important to evaluate before making any more changes
        merges = mergeProcess(state);
        if(merges == 0) {
            splits = splitProcess(state);            
        }
        updateRepresentatives(state);

        // create new population with individuals from metapops, without foreigns
        Population newPop = (Population) state.population.emptyClone();
        newPop.subpops = new Subpopulation[metaPops.size()];
        for (int i = 0; i < metaPops.size(); i++) {
            newPop.subpops[i] = metaPops.get(i).pop;
            newPop.subpops[i].individuals = metaPops.get(i).inds;
        }
        return newPop;
    }

    /*
     Update after breeding and prepare populations for evaluation
     */
    @Override
    public Population postBreedingExchangePopulation(EvolutionState state) {
        // Update metapop with new individuals generated by the breeding process
        for (int i = 0; i < metaPops.size(); i++) {
            MetaPopulation mp = metaPops.get(i);
            mp.pop = state.population.subpops[i];
            mp.inds = state.population.subpops[i].individuals;
        }

        // Update allocations
        for (int i = 0; i < metaPops.size(); i++) {
            for (Integer ag : metaPops.get(i).agents) {
                allocations[ag] = i;
            }
        }

        return state.population;
    }

    protected void updateRepresentatives(EvolutionState state) {
        CoevolutionaryEvaluator base = (CoevolutionaryEvaluator) ((MetaEvaluator) state.evaluator).getBaseEvaluator();
        Individual[][] newElites = new Individual[metaPops.size()][base.getEliteIndividuals()[0].length];
        for (int i = 0; i < metaPops.size(); i++) {
            MetaPopulation mp = metaPops.get(i);
            Individual[] allInds = sortedCopy(mp.inds);
            for (int j = 0; j < newElites[i].length; j++) {
                newElites[i][j] = (Individual) allInds[j].clone();
            }
        }
        base.setEliteIndividuals(newElites);
    }

    /*
     Initialization, merging and spliting algorithms
     */
    protected void initializationProcess(EvolutionState state) {
        if (homogeneousStart) {
            MetaPopulation homo = new MetaPopulation();
            for (int i = 0; i < state.population.subpops.length; i++) {
                homo.agents.add(i);
            }
            homo.pop = state.population.subpops[0];
            homo.inds = homo.pop.individuals;
            metaPops.add(homo);
        } else {
            for (int i = 0; i < state.population.subpops.length; i++) {
                MetaPopulation pi = new MetaPopulation();
                pi.agents.add(i);
                pi.pop = state.population.subpops[i];
                pi.inds = pi.pop.individuals;
                metaPops.add(pi);
            }
        }
    }

    protected abstract int mergeProcess(EvolutionState state);

    protected abstract int splitProcess(EvolutionState state);

    protected static class MetaPopulation implements Serializable {

        private static final long serialVersionUID = 1L;

        List<Integer> agents;
        Subpopulation pop;
        Individual[] inds;
        int age;
        int lockDown;

        MetaPopulation() {
            this.agents = new ArrayList<>();
            this.age = 0;
        }

        @Override
        public String toString() {
            String s = "[";
            for (int i = 0; i < agents.size() - 1; i++) {
                s += agents.get(i) + ",";
            }
            if (agents.size() > 0) {
                s += agents.get(agents.size() - 1);
            }
            return s + "]";
        }
    }

    /*
     Uses final scores
     Sorts from the highest fitness to the lowest fitness
     */
    protected class FitnessComparator implements Comparator<Individual> {

        @Override
        public int compare(Individual o1, Individual o2) {
            return Double.compare(o2.fitness.fitness(), o1.fitness.fitness());
        }
    }

    protected Individual[] sortedCopy(Individual[] inds) {
        inds = Arrays.copyOf(inds, inds.length);
        Arrays.sort(inds, new FitnessComparator());
        return inds;
    }

    protected Individual[] getElitePortion(Individual[] inds, int num) {
        inds = sortedCopy(inds);
        Individual[] elite = new Individual[num];
        System.arraycopy(inds, 0, elite, 0, num);
        return elite;
    }

    protected BehaviourResult getAgentBR(Individual ind, int agent) {
        ExpandedFitness nf = (ExpandedFitness) ind.fitness;
        SubpopEvaluationResult ser = (SubpopEvaluationResult) nf.getEvaluationResults()[behaviourIndex];
        return (BehaviourResult) ser.getSubpopEvaluation(agent);
    }

    public int[] getAllocations() {
        return allocations;
    }

    protected List<MetaPopulation> getMetaPopulations() {
        return metaPops;
    }

    @Override
    public String runComplete(EvolutionState state) {
        return null;
    }

}
